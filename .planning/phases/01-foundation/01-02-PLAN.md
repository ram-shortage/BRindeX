---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - Cargo.toml
  - src/lib.rs
  - src/db/mod.rs
  - src/db/schema.rs
  - src/db/ops.rs
autonomous: true

must_haves:
  truths:
    - "Database opens with WAL mode enabled and correct PRAGMAs set"
    - "Schema creates volumes and files tables with proper indexes"
    - "Batch insert of 100K records completes in under 1 second"
    - "Database survives simulated crash (kill process) without corruption"
  artifacts:
    - path: "src/db/mod.rs"
      provides: "Database connection management with WAL configuration"
      exports: ["Database", "open_database"]
      contains: "journal_mode.*WAL"
    - path: "src/db/schema.rs"
      provides: "Table creation and migration logic"
      contains: "CREATE TABLE.*files"
    - path: "src/db/ops.rs"
      provides: "CRUD operations and batch inserts"
      exports: ["insert_volume", "batch_insert_files", "search_files"]
  key_links:
    - from: "src/db/mod.rs"
      to: "src/db/schema.rs"
      via: "schema initialization on open"
      pattern: "schema::init"
    - from: "src/db/ops.rs"
      to: "rusqlite::Connection"
      via: "prepared statements"
      pattern: "prepare_cached"
---

<objective>
Create the SQLite database layer with WAL mode, optimized schema, and high-performance batch operations.

Purpose: Provide crash-safe, persistent storage for the file index with sub-second query performance on millions of records.
Output: Database module that can create, populate, and query the file index.
</objective>

<execution_context>
@/Users/brett/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brett/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add rusqlite dependency and create database module structure</name>
  <files>Cargo.toml, src/lib.rs, src/db/mod.rs</files>
  <action>
Update Cargo.toml to add rusqlite:
```toml
rusqlite = { version = "0.38", features = ["bundled"] }
```

Update src/lib.rs:
- Uncomment or add `pub mod db;`
- Add Database error variant to FFIError if not present

Create src/db/mod.rs with:
- Submodule declarations: `mod schema; mod ops; pub use ops::*;`
- `Database` struct wrapping `rusqlite::Connection`
- `open_database(path: &Path) -> Result<Database>` function that:
  1. Creates parent directory if it doesn't exist
  2. Opens connection with `Connection::open(path)`
  3. Configures WAL mode: `PRAGMA journal_mode = WAL`
  4. Sets `PRAGMA synchronous = NORMAL` (safe for WAL, faster than FULL)
  5. Sets `PRAGMA temp_store = MEMORY`
  6. Sets `PRAGMA mmap_size = 268435456` (256MB memory-mapped I/O)
  7. Sets `PRAGMA cache_size = -64000` (64MB page cache)
  8. Sets `PRAGMA busy_timeout = 5000` (5 second busy timeout)
  9. Calls `schema::init(&conn)` to create tables
  10. Returns wrapped Database

Follow Pattern 2 from RESEARCH.md for PRAGMA configuration.
  </action>
  <verify>
`cargo check` passes. `open_database` function compiles with correct PRAGMA setup.
  </verify>
  <done>
Database module compiles with WAL mode configuration and proper PRAGMAs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement database schema with optimized indexes</name>
  <files>src/db/schema.rs</files>
  <action>
Create src/db/schema.rs with:

**init(conn: &Connection) -> Result<()>** function that executes:

```sql
CREATE TABLE IF NOT EXISTS volumes (
    id INTEGER PRIMARY KEY,
    drive_letter TEXT NOT NULL UNIQUE,
    volume_serial TEXT NOT NULL,
    fs_type TEXT NOT NULL,  -- 'NTFS', 'FAT32', 'exFAT'
    last_usn INTEGER,       -- Last processed USN (NTFS only)
    usn_journal_id INTEGER, -- USN Journal ID (NTFS only)
    last_scan_time INTEGER  -- Unix timestamp
);

CREATE TABLE IF NOT EXISTS files (
    id INTEGER PRIMARY KEY,
    volume_id INTEGER NOT NULL REFERENCES volumes(id),
    file_ref INTEGER,       -- MFT file reference number (NTFS)
    parent_ref INTEGER,     -- Parent MFT reference (NTFS) or parent file id (FAT)
    name TEXT NOT NULL,     -- Filename only (not full path)
    size INTEGER NOT NULL DEFAULT 0,
    modified INTEGER,       -- Unix timestamp
    is_dir INTEGER NOT NULL DEFAULT 0,
    UNIQUE(volume_id, file_ref)
);

-- Index for fast filename search (case-insensitive)
CREATE INDEX IF NOT EXISTS idx_files_name ON files(name COLLATE NOCASE);

-- Index for path reconstruction (parent lookups)
CREATE INDEX IF NOT EXISTS idx_files_parent ON files(volume_id, parent_ref);

-- Index for volume-based operations
CREATE INDEX IF NOT EXISTS idx_files_volume ON files(volume_id);
```

Use `conn.execute_batch()` for multi-statement execution.

This matches the Database Schema from RESEARCH.md exactly.
  </action>
  <verify>
`cargo check` passes. Schema SQL matches RESEARCH.md specification.
  </verify>
  <done>
Schema module creates volumes and files tables with all required indexes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement CRUD operations and batch inserts</name>
  <files>src/db/ops.rs</files>
  <action>
Create src/db/ops.rs with:

**Data structures:**
```rust
pub struct VolumeInfo {
    pub id: i64,
    pub drive_letter: String,
    pub volume_serial: String,
    pub fs_type: String,  // "NTFS", "FAT32", "exFAT"
}

pub struct FileEntry {
    pub volume_id: i64,
    pub file_ref: Option<i64>,
    pub parent_ref: Option<i64>,
    pub name: String,
    pub size: i64,
    pub modified: Option<i64>,  // Unix timestamp
    pub is_dir: bool,
}
```

**Volume operations:**
- `insert_volume(conn, drive_letter, serial, fs_type) -> Result<i64>` - Insert or update volume, return id
- `get_volume(conn, drive_letter) -> Result<Option<VolumeInfo>>` - Get volume by drive letter
- `update_volume_usn(conn, volume_id, last_usn, journal_id) -> Result<()>` - Update USN tracking

**File operations:**
- `batch_insert_files(conn, files: &[FileEntry]) -> Result<usize>` - Batch insert with transactions
  - Use BATCH_SIZE of 100,000 records per transaction (per RESEARCH.md)
  - Use `prepare_cached` for statement reuse
  - Return count of inserted records
  - Follow Pattern 4 from RESEARCH.md
- `delete_volume_files(conn, volume_id) -> Result<usize>` - Delete all files for a volume
- `search_files(conn, query: &str, limit: usize) -> Result<Vec<FileEntry>>` - Search by name (LIKE %query%)
- `get_file_count(conn, volume_id: Option<i64>) -> Result<i64>` - Count files (optionally by volume)

**Path reconstruction:**
- `reconstruct_path(conn, volume_id: i64, file_ref: i64) -> Result<PathBuf>` - Walk parent_ref chain to build full path

Use `prepare_cached` for all repeated statements to optimize performance.
  </action>
  <verify>
`cargo check` passes. All CRUD operations compile without errors.
  </verify>
  <done>
Database operations module provides batch inserts (100K/transaction), CRUD, and path reconstruction.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `cargo check` passes with no errors
2. Database module structure:
   ```
   src/db/
   ├── mod.rs      # Connection management, WAL config
   ├── schema.rs   # Table creation, indexes
   └── ops.rs      # CRUD operations, batch inserts
   ```
3. WAL mode configured correctly (journal_mode, synchronous, mmap_size)
4. Schema matches RESEARCH.md specification (volumes, files tables, 3 indexes)
5. Batch insert uses 100K batch size with transactions

Note: Performance testing (batch insert speed) requires runtime testing with actual data.
</verification>

<success_criteria>
- [ ] rusqlite dependency added with bundled feature
- [ ] Database opens with WAL mode and optimized PRAGMAs
- [ ] Schema creates volumes and files tables
- [ ] Three indexes created (name, parent, volume)
- [ ] Batch insert function handles 100K records per transaction
- [ ] CRUD operations for volumes and files implemented
- [ ] Path reconstruction from parent_ref chain works
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
