---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - Cargo.toml
  - src/lib.rs
  - src/indexer/mod.rs
  - src/indexer/volume.rs
  - src/indexer/mft.rs
  - src/indexer/fat.rs
  - src/bin/ffi-service.rs
  - src/service/mod.rs
autonomous: true

must_haves:
  truths:
    - "Service detects NTFS vs FAT32/exFAT volumes correctly"
    - "NTFS volumes indexed via MFT enumeration at ~1 second per 100K files"
    - "FAT volumes indexed via walkdir directory traversal"
    - "Service starts, indexes configured volumes in background, and persists to database"
    - "Service can be stopped cleanly during indexing without corruption"
  artifacts:
    - path: "src/indexer/mod.rs"
      provides: "Indexing orchestration and background task management"
      exports: ["Indexer", "start_background_indexer"]
    - path: "src/indexer/volume.rs"
      provides: "Volume detection and filesystem type classification"
      exports: ["detect_volumes", "VolumeType"]
      contains: "GetVolumeInformation"
    - path: "src/indexer/mft.rs"
      provides: "NTFS MFT reader using usn-journal-rs"
      exports: ["scan_ntfs_volume"]
      contains: "Mft::new"
    - path: "src/indexer/fat.rs"
      provides: "FAT volume directory walker using walkdir"
      exports: ["scan_fat_volume"]
      contains: "WalkDir::new"
  key_links:
    - from: "src/indexer/mod.rs"
      to: "src/db/ops.rs"
      via: "batch_insert_files for persistence"
      pattern: "batch_insert_files"
    - from: "src/indexer/mft.rs"
      to: "usn-journal-rs"
      via: "MFT iteration"
      pattern: "mft\\.iter\\(\\)"
    - from: "src/service/mod.rs"
      to: "src/indexer/mod.rs"
      via: "start_background_indexer call"
      pattern: "start_background_indexer"
---

<objective>
Implement initial file indexing for NTFS (via MFT) and FAT (via walkdir), integrating with the service lifecycle.

Purpose: Build the complete file index on service start, achieving the ~1 second per 100K files performance target for NTFS.
Output: Service that detects volumes, indexes files appropriately by filesystem type, and persists to SQLite.
</objective>

<execution_context>
@/Users/brett/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brett/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add indexing dependencies and volume detection</name>
  <files>Cargo.toml, src/lib.rs, src/indexer/mod.rs, src/indexer/volume.rs</files>
  <action>
Update Cargo.toml to add indexing dependencies:
```toml
usn-journal-rs = "0.4"
walkdir = "2"
windows = { version = "0.62", features = [
    "Win32_Storage_FileSystem",
    "Win32_System_Ioctl",
    "Win32_Foundation",
] }
```

Update src/lib.rs:
- Add `pub mod indexer;`
- Add Indexer error variant to FFIError if needed

Create src/indexer/mod.rs with:
- Submodule declarations: `mod volume; mod mft; mod fat;`
- Re-exports: `pub use volume::*; pub use mft::*; pub use fat::*;`
- `Indexer` struct holding database connection and shutdown receiver
- `start_background_indexer(db: Database, shutdown_rx: Receiver<()>) -> JoinHandle<()>` function that:
  1. Spawns a thread for indexing
  2. Detects volumes using volume::detect_volumes()
  3. For each volume, calls appropriate scanner (mft or fat based on fs_type)
  4. Periodically checks shutdown_rx to allow clean termination
  5. Logs progress via tracing

Create src/indexer/volume.rs with:
- `VolumeType` enum: NTFS, FAT32, ExFAT, Unknown
- `VolumeInfo` struct: drive_letter, volume_serial, fs_type: VolumeType, total_size, free_space
- `detect_volumes() -> Vec<VolumeInfo>` function that:
  1. Iterates drive letters A-Z
  2. Uses `GetVolumeInformationW` from windows crate to get filesystem name
  3. Uses `GetDiskFreeSpaceExW` for size info
  4. Returns list of detected volumes with their types
- `is_ntfs(info: &VolumeInfo) -> bool` helper function

Handle Windows API errors gracefully (skip inaccessible drives).
  </action>
  <verify>
`cargo check` passes. Volume detection compiles with Windows API calls.
  </verify>
  <done>
Indexer module structure created with volume detection that identifies NTFS vs FAT filesystems.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement NTFS MFT reader</name>
  <files>src/indexer/mft.rs</files>
  <action>
Create src/indexer/mft.rs with:

**scan_ntfs_volume(drive_letter: char, db: &Database, shutdown_rx: &Receiver<()>) -> Result<usize>** function:

1. Open volume using `usn_journal_rs::volume::Volume::from_drive_letter(drive_letter)`
2. Create MFT reader: `Mft::new(&volume)`
3. Insert or update volume record in database
4. Initialize batch buffer: `Vec<FileEntry>` with capacity 100,000
5. Iterate MFT entries with `mft.iter()`:
   - For each entry, extract: file_reference, parent_file_reference, file_name, file_size, last_write_time, is_directory
   - Convert to `FileEntry` struct
   - Add to batch buffer
   - When buffer reaches 100K, call `batch_insert_files` and clear buffer
   - Every 100K entries, check `shutdown_rx.try_recv()` for shutdown signal
   - Log progress every 100K entries
6. Insert any remaining entries in buffer
7. Update volume's last_scan_time
8. Return total count of indexed files

Follow Pattern 3 from RESEARCH.md for MFT iteration.

Handle errors gracefully:
- Log and skip unreadable MFT entries (don't fail entire scan)
- Return error only for volume-level failures (can't open, no permissions)
  </action>
  <verify>
`cargo check` passes. MFT scanner compiles with usn-journal-rs usage.
  </verify>
  <done>
NTFS MFT reader streams entries to database in 100K batches with shutdown support.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement FAT directory walker and wire up service</name>
  <files>src/indexer/fat.rs, src/service/mod.rs, src/bin/ffi-service.rs</files>
  <action>
Create src/indexer/fat.rs with:

**scan_fat_volume(drive_letter: char, db: &Database, shutdown_rx: &Receiver<()>) -> Result<usize>** function:

1. Construct root path: `format!("{}:\\", drive_letter)`
2. Insert or update volume record in database
3. Initialize batch buffer and file_id counter
4. Use `WalkDir::new(root).follow_links(false)` to iterate:
   - For each entry, extract: path, file_name, is_dir, size, modified time
   - Generate synthetic file_ref (incrementing counter since FAT has no MFT refs)
   - Track parent_ref using path hierarchy (store path -> id mapping)
   - Add to batch buffer
   - When buffer reaches 100K, call `batch_insert_files` and clear buffer
   - Every 10K entries, check shutdown signal
   - Log progress every 50K entries
5. Insert remaining entries
6. Update volume's last_scan_time
7. Return total count

Follow Pattern 5 from RESEARCH.md for walkdir usage.

**Update src/service/mod.rs:**
- In `run_service()`, after reporting StartPending:
  1. Open database: `db::open_database(&config.data_dir.join("index.db"))`
  2. Create shutdown channel for indexer
  3. Call `indexer::start_background_indexer(db, indexer_shutdown_rx)`
  4. Store indexer handle
- In shutdown sequence:
  1. Send shutdown to indexer
  2. Wait for indexer thread to finish (with timeout)
  3. Close database

**Update src/bin/ffi-service.rs:**
- Ensure data directory exists before opening database
- Log startup with version info
  </action>
  <verify>
`cargo check` passes. FAT scanner compiles with walkdir. Service wires up database and indexer.
  </verify>
  <done>
FAT directory walker implemented, service integrates database and background indexer with graceful shutdown.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `cargo check` passes with no errors
2. `cargo build --release --bin ffi-service` produces working executable
3. Indexer module structure:
   ```
   src/indexer/
   ├── mod.rs      # Orchestration, background task
   ├── volume.rs   # Volume detection
   ├── mft.rs      # NTFS MFT reader
   └── fat.rs      # FAT directory walker
   ```
4. Service lifecycle integrates indexer:
   - Database opened during StartPending
   - Background indexer started before Running reported
   - Indexer receives shutdown signal on Stop
   - Graceful termination without corruption

Note: Full end-to-end testing requires Windows environment with actual volumes. On macOS/Linux, verify compilation only.
</verification>

<success_criteria>
- [ ] usn-journal-rs and walkdir dependencies added
- [ ] Volume detection identifies NTFS vs FAT32/exFAT filesystems
- [ ] NTFS MFT reader streams to database in 100K batches
- [ ] FAT walker traverses directories with synthetic file refs
- [ ] Both scanners respect shutdown signal for clean termination
- [ ] Service integrates database open and indexer startup
- [ ] Graceful shutdown sequence: signal indexer, wait, close db
- [ ] Progress logging during indexing
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
