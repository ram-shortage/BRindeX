---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/lib.rs
  - src/bin/ffi-service.rs
  - src/service/mod.rs
  - src/service/control.rs
  - src/service/config.rs
autonomous: true

must_haves:
  truths:
    - "Service binary compiles without errors on Windows target"
    - "Service can be installed via sc.exe and appears in Services console"
    - "Service starts, reports Running state, and stops gracefully on command"
    - "Service handles Stop and Shutdown control events correctly"
  artifacts:
    - path: "Cargo.toml"
      provides: "Project configuration with windows-service, tokio, tracing dependencies"
      contains: "windows-service"
    - path: "src/lib.rs"
      provides: "Shared types and error definitions"
      exports: ["FFIError", "Result"]
    - path: "src/bin/ffi-service.rs"
      provides: "Windows service entry point with dispatcher"
      contains: "service_dispatcher::start"
    - path: "src/service/mod.rs"
      provides: "Service lifecycle management"
      contains: "run_service"
    - path: "src/service/control.rs"
      provides: "Service control handler for stop/shutdown"
      contains: "ServiceControlHandlerResult"
    - path: "src/service/config.rs"
      provides: "Service configuration loading"
      contains: "ServiceConfig"
  key_links:
    - from: "src/bin/ffi-service.rs"
      to: "src/service/mod.rs"
      via: "run_service function call"
      pattern: "service::run_service"
    - from: "src/service/mod.rs"
      to: "src/service/control.rs"
      via: "control handler registration"
      pattern: "register.*event_handler"
---

<objective>
Create the Windows service foundation with proper lifecycle management, control handling, and project structure.

Purpose: Establish the service skeleton that will host the indexer. This is the foundation all other Phase 1 work builds upon.
Output: Compilable Windows service binary that can be installed, started, stopped, and uninstalled.
</objective>

<execution_context>
@/Users/brett/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brett/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Rust project with service dependencies</name>
  <files>Cargo.toml, src/lib.rs</files>
  <action>
Initialize Rust project with `cargo init` if not already present.

Configure Cargo.toml with:
- Package name: `ffi` (FastFileIndex)
- Edition: 2021
- Binary target: `ffi-service` (src/bin/ffi-service.rs)

Add dependencies as specified in RESEARCH.md:
```toml
[dependencies]
windows-service = "0.7"
tokio = { version = "1.43", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
tracing-appender = "0.2"
thiserror = "2.0"
anyhow = "1.0"
```

Create src/lib.rs with:
- `FFIError` enum using thiserror (variants: Service, Database, Indexer, Io)
- Type alias `pub type Result<T> = std::result::Result<T, FFIError>`
- Module declarations for `service`, `db`, `indexer` (commented out db/indexer for now)

Do NOT add rusqlite, usn-journal-rs, or walkdir yet - those come in later plans.
  </action>
  <verify>
`cargo check` passes without errors.
  </verify>
  <done>
Cargo.toml has correct dependencies, src/lib.rs compiles with FFIError and Result types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement service control handler and lifecycle</name>
  <files>src/service/mod.rs, src/service/control.rs, src/service/config.rs</files>
  <action>
Create src/service/ directory with three files:

**src/service/config.rs:**
- Define `ServiceConfig` struct with fields: `data_dir: PathBuf` (defaults to C:\ProgramData\FFI)
- Implement `Default` trait
- Implement `ServiceConfig::load()` that reads from config file or returns default

**src/service/control.rs:**
- Create `ServiceState` struct holding shutdown channel sender
- Implement control event handler function that handles:
  - `ServiceControl::Stop` -> send shutdown signal, return NoError
  - `ServiceControl::Shutdown` -> send shutdown signal, return NoError
  - `ServiceControl::Interrogate` -> return NoError
  - Other events -> return NotImplemented
- Function returns `ServiceControlHandlerResult`

**src/service/mod.rs:**
- Re-export config and control modules
- Implement `run_service()` function following Pattern 1 from RESEARCH.md:
  1. Create shutdown channel (mpsc)
  2. Register control handler
  3. Report StartPending with 60s wait_hint
  4. Increment checkpoint to show progress
  5. Report Running with STOP | SHUTDOWN accepted
  6. Wait for shutdown signal
  7. Report StopPending
  8. Report Stopped
- Use tracing for logging each state transition
  </action>
  <verify>
`cargo check` passes. Module structure is correct (service::run_service exists).
  </verify>
  <done>
Service module compiles with control handler, config loading, and lifecycle management.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create service binary entry point</name>
  <files>src/bin/ffi-service.rs</files>
  <action>
Create src/bin/ffi-service.rs with:

1. Use `windows_service::define_windows_service!` macro to define service entry
2. Service name: "FFIService"
3. Display name: "FastFileIndex Service"
4. Initialize tracing subscriber with file appender to `{data_dir}/ffi-service.log`
5. Call `service_dispatcher::start()` to run the service
6. Handle errors from dispatcher with proper error logging

Follow the Complete Service Entry Point example from RESEARCH.md.

The binary should:
- Compile as a Windows executable
- Be runnable directly (will fail outside SCM, but should compile)
- Support both service mode and potential future CLI mode

Add logging initialization before service starts:
```rust
let file_appender = tracing_appender::rolling::daily("C:\\ProgramData\\FFI\\logs", "ffi-service.log");
let (non_blocking, _guard) = tracing_appender::non_blocking(file_appender);
tracing_subscriber::fmt()
    .with_writer(non_blocking)
    .with_env_filter("info")
    .init();
```
  </action>
  <verify>
`cargo build --bin ffi-service` compiles successfully. Binary exists at target/debug/ffi-service.exe (on Windows) or cross-compilation succeeds.
  </verify>
  <done>
Service binary compiles and contains proper service dispatcher setup with logging.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `cargo check` passes with no errors
2. `cargo build --release --bin ffi-service` produces executable
3. Code structure matches RESEARCH.md recommended layout:
   ```
   src/
   ├── bin/
   │   └── ffi-service.rs
   ├── service/
   │   ├── mod.rs
   │   ├── control.rs
   │   └── config.rs
   └── lib.rs
   ```
4. Service lifecycle follows Windows best practices (StartPending -> Running -> StopPending -> Stopped)

Note: Full service installation testing requires Windows environment. On macOS/Linux, verify compilation and code structure.
</verification>

<success_criteria>
- [ ] Rust project initialized with correct dependencies
- [ ] FFIError and Result types defined in lib.rs
- [ ] Service control handler properly handles Stop/Shutdown events
- [ ] Service lifecycle reports correct states to SCM
- [ ] Binary compiles successfully
- [ ] Logging configured to write to data directory
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
