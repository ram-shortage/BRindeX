---
phase: 02-real-time-updates
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/indexer/fat_reconciler.rs
  - src/indexer/mod.rs
  - src/service/volume_watcher.rs
  - src/service/mod.rs
  - src/db/ops.rs
  - src/db/schema.rs
autonomous: true

must_haves:
  truths:
    - "FAT32/exFAT volume changes detected via periodic rescan at configured interval"
    - "Volume mount event triggers index refresh for configured volumes"
    - "Volume unmount marks volume offline but preserves index data"
    - "Offline volumes auto-delete after 7 days"
    - "Service handles volume reconnect with quick reconciliation"
  artifacts:
    - path: "src/indexer/fat_reconciler.rs"
      provides: "Periodic FAT volume reconciliation scheduler"
      exports: ["FatReconciler", "start_fat_reconciler"]
    - path: "src/service/volume_watcher.rs"
      provides: "Volume mount/unmount detection"
      exports: ["VolumeWatcher", "start_volume_watcher"]
    - path: "src/db/ops.rs"
      provides: "Volume state management"
      contains: "update_volume_state"
  key_links:
    - from: "src/service/volume_watcher.rs"
      to: "src/indexer/mod.rs"
      via: "mount event triggers index_volume"
      pattern: "handle_volume_mount"
    - from: "src/indexer/fat_reconciler.rs"
      to: "src/indexer/fat.rs"
      via: "reconciler calls scan_fat_volume"
      pattern: "scan_fat_volume"
---

<objective>
Implement FAT/exFAT periodic reconciliation and volume mount/unmount lifecycle management.

Purpose: Keep FAT volume indexes current via periodic full rescans, handle volume lifecycle events (mount/unmount/reconnect), and manage offline volume data cleanup.

Output: Working FAT reconciler that runs periodic scans at configured intervals, volume watcher that detects mount/unmount events, and volume state machine managing online/offline transitions with automatic cleanup.
</objective>

<execution_context>
@/Users/brett/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brett/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-real-time-updates/02-RESEARCH.md
@.planning/phases/02-real-time-updates/02-CONTEXT.md
@.planning/phases/02-real-time-updates/02-01-SUMMARY.md
@src/service/config.rs
@src/indexer/mod.rs
@src/indexer/fat.rs
@src/db/ops.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement volume state machine and database operations</name>
  <files>src/db/schema.rs, src/db/ops.rs, src/lib.rs</files>
  <action>
1. Add VolumeState enum to src/lib.rs:
   - Online: Volume mounted and actively monitored
   - Offline { since: i64 }: Volume unmounted, data preserved
   - Indexing: Initial indexing in progress
   - Rescanning: Background rescan in progress (after journal wrap)
   - Disabled: Configured but not enabled for indexing

2. Update volumes table schema in src/db/schema.rs:
   - Add state column (TEXT, default 'online')
   - Add offline_since column (INTEGER, nullable)
   - Add volume_serial column (INTEGER) for detecting volume swaps

3. Add volume state operations to src/db/ops.rs:
   - update_volume_state(conn, volume_id, state: VolumeState) -> Result<()>
   - get_volume_state(conn, volume_id) -> Result<VolumeState>
   - get_volume_by_serial(conn, serial: u32) -> Option<VolumeInfo>
   - cleanup_old_offline_volumes(conn, retention_days: u32) -> Result<usize>
     * Delete files for volumes where state='offline' AND offline_since < cutoff
     * Delete those volumes
     * Return count of deleted file entries

4. Add helper function get_volume_serial(drive_letter: char) -> Option<u32>:
   - Use GetVolumeInformationW to get volume serial number
   - Gate with #[cfg(windows)]

Follow RESEARCH.md Volume State Machine pattern for state transitions.
  </action>
  <verify>cargo check passes; VolumeState enum defined; schema update compiles; cleanup query returns count</verify>
  <done>Volume state management in database with cleanup for old offline volumes</done>
</task>

<task type="auto">
  <name>Task 2: Implement FAT reconciliation scheduler</name>
  <files>src/indexer/fat_reconciler.rs, src/indexer/mod.rs</files>
  <action>
1. Create src/indexer/fat_reconciler.rs with:

   FatReconciler struct:
   - volumes: Vec<(char, Duration)> - drive letter and reconcile interval pairs
   - last_scan: HashMap<char, Instant> - when each volume was last scanned
   - db_path: PathBuf

   Methods:
   - new(config: &Config, db_path: PathBuf) -> Self:
     * Filter config.volumes for FAT-type volumes (not NTFS)
     * Get reconcile_interval_mins from each volume config (default 30)
     * Initialize last_scan to Instant::now() (don't scan immediately on start)

   - check_and_reconcile(&mut self, shutdown_rx: &Receiver<()>) -> Result<()>:
     * For each volume, check if (now - last_scan) >= interval
     * If due for scan:
       - Set volume state to Rescanning
       - Call scan_fat_volume from src/indexer/fat.rs (reuse Phase 1 code)
       - Update last_scan timestamp
       - Set volume state back to Online
       - Check shutdown_rx between volumes

2. Add fat_reconciler_loop() function:
   - Parameters: config, db_path, shutdown_rx: Receiver<()>
   - Create FatReconciler
   - Loop every 60 seconds:
     * Check shutdown_rx.try_recv() for exit signal
     * Call check_and_reconcile()
     * Run cleanup_old_offline_volumes() once per day (track last cleanup time)

3. Export module in src/indexer/mod.rs

4. Add start_fat_reconciler() in src/indexer/mod.rs:
   - Spawns reconciler thread
   - Returns join handle and shutdown sender

Per CONTEXT.md: No file watchers for FAT - periodic full scan only (simpler, more reliable).
Per CONTEXT.md: Default reconciliation interval 30 minutes, configurable per-volume.
  </action>
  <verify>cargo check passes; FatReconciler compiles; reconciler respects shutdown signal</verify>
  <done>FAT reconciliation scheduler runs periodic full scans at configured intervals</done>
</task>

<task type="auto">
  <name>Task 3: Implement volume mount/unmount detection and service integration</name>
  <files>src/service/volume_watcher.rs, src/service/mod.rs, src/indexer/mod.rs</files>
  <action>
1. Create src/service/volume_watcher.rs with:

   VolumeEvent enum:
   - Mounted(char) - drive letter
   - Unmounted(char)

   VolumeWatcher struct:
   - event_tx: Sender<VolumeEvent>
   - shutdown_rx: Receiver<()>

2. Add start_volume_watcher() function (Windows-only):
   - Creates hidden window for message pump
   - Registers window class with wnd_proc
   - In wnd_proc, handle WM_DEVICECHANGE:
     * DBT_DEVICEARRIVAL: Parse DEV_BROADCAST_VOLUME, get drive letters from unitmask, send Mounted events
     * DBT_DEVICEREMOVECOMPLETE: Parse DEV_BROADCAST_VOLUME, send Unmounted events
   - Run GetMessage loop until shutdown signal
   - Follow RESEARCH.md Pattern 3 for WM_DEVICECHANGE handling

3. Add event handler functions in src/indexer/mod.rs:

   handle_volume_mount(drive_letter: char, config: &Config, db: &Database):
   - Check if volume is configured for indexing (config.volumes.get)
   - If not configured, ignore
   - Get volume serial, compare with stored serial
   - If serial mismatch (different physical volume):
     * Mark old data as offline
     * Start fresh index
   - If serial matches:
     * Set state to Online
     * If was Offline: trigger quick reconciliation (full scan for now)
   - For NTFS: Start USN monitor
   - For FAT: Add to reconciler

   handle_volume_unmount(drive_letter: char, db: &Database):
   - Set volume state to Offline { since: now() }
   - Stop any active monitors/reconcilers for this volume
   - Log "Volume X offline, data preserved for 7 days"

4. Update src/service/mod.rs:
   - Start volume_watcher thread on service start
   - Spawn event handler thread that receives VolumeEvents
   - Debounce mount events (100ms window) per RESEARCH.md pitfall
   - Wire shutdown signal to volume watcher

5. Export volume_watcher module in src/service/mod.rs

Gate Windows code with #[cfg(windows)]. Non-Windows provides no-op stub.
  </action>
  <verify>cargo check passes; cargo build --release succeeds; volume watcher compiles with message pump</verify>
  <done>Volume lifecycle management with mount/unmount detection wired to service</done>
</task>

</tasks>

<verification>
1. cargo check passes with no errors
2. cargo build --release succeeds
3. Volume state transitions work correctly (Online -> Offline -> Online)
4. FAT reconciler respects configured intervals
5. Volume watcher compiles with WM_DEVICECHANGE handling
6. Service integrates all Phase 2 components
7. Offline volume cleanup runs periodically
</verification>

<success_criteria>
- VolumeState enum with Online/Offline/Indexing/Rescanning/Disabled states
- Database schema updated with state, offline_since, volume_serial columns
- FatReconciler runs periodic scans at configured intervals per volume
- VolumeWatcher detects mount/unmount via WM_DEVICECHANGE
- Mount triggers index refresh (or fresh index if serial changed)
- Unmount preserves data and marks offline
- Cleanup removes offline volumes after 7 days
- All code compiles on Windows and non-Windows (conditional compilation)
</success_criteria>

<output>
After completion, create `.planning/phases/02-real-time-updates/02-02-SUMMARY.md`
</output>
