---
phase: 03-search-experience
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/lib.rs
  - src/search/mod.rs
  - src/search/grammar.pest
  - src/search/parser.rs
  - src/search/filters.rs
  - src/search/query.rs
autonomous: true

must_haves:
  truths:
    - "Search query parses into structured filters"
    - "Wildcards (* and ?) translate to SQL LIKE patterns"
    - "Extension filter (ext:pdf) works"
    - "Size filter (size:>10mb) works"
    - "Type filter (type:folder) works"
    - "Date filter (modified:today) works"
    - "Path scope (path:C:\\Projects) works"
  artifacts:
    - path: "src/search/grammar.pest"
      provides: "PEG grammar for search syntax"
      contains: "query = { SOI ~ term* ~ EOI }"
    - path: "src/search/parser.rs"
      provides: "Grammar parser"
      exports: ["parse_query", "ParsedQuery"]
    - path: "src/search/filters.rs"
      provides: "Filter types"
      exports: ["Filter", "SizeOp", "DateOp", "FileType"]
    - path: "src/search/query.rs"
      provides: "SQL query builder"
      exports: ["build_sql_query"]
  key_links:
    - from: "src/search/parser.rs"
      to: "src/search/grammar.pest"
      via: "pest grammar derive"
      pattern: "#\\[grammar = \"src/search/grammar.pest\"\\]"
    - from: "src/search/query.rs"
      to: "src/search/filters.rs"
      via: "Filter enum usage"
      pattern: "Filter::"
---

<objective>
Implement search syntax parser using pest grammar for filters and wildcards.

Purpose: Users need expressive search with filters like `ext:pdf size:>10mb`. A grammar-based parser provides maintainable syntax handling and clear error messages.

Output: Search module with grammar, parser, filter types, and SQL query builder.
</objective>

<execution_context>
@/Users/brett/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brett/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search-experience/03-RESEARCH.md

# Existing code context
@src/lib.rs
@src/db/ops.rs
@src/db/schema.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pest dependencies and create search module structure</name>
  <files>Cargo.toml, src/lib.rs, src/search/mod.rs, src/search/filters.rs</files>
  <action>
1. Add pest and chrono to Cargo.toml:
   ```toml
   pest = "2.8"
   pest_derive = "2.8"
   chrono = { version = "0.4", features = ["serde"] }
   ```

2. Create src/search/mod.rs:
   ```rust
   pub mod filters;
   pub mod parser;
   pub mod query;

   pub use filters::*;
   pub use parser::{parse_query, ParsedQuery};
   pub use query::build_sql_query;
   ```

3. Create src/search/filters.rs with filter types:
   ```rust
   #[derive(Debug, Clone, PartialEq)]
   pub enum Filter {
       Extension(String),           // ext:pdf
       Size(SizeOp, i64),           // size:>10mb (bytes)
       Type(FileType),              // type:folder
       Modified(DateOp, i64),       // modified:>2024-01-01 (unix timestamp)
       PathScope(String),           // path:C:\Projects
   }

   #[derive(Debug, Clone, Copy, PartialEq)]
   pub enum SizeOp {
       GreaterThan,
       GreaterEqual,
       LessThan,
       LessEqual,
   }

   #[derive(Debug, Clone, Copy, PartialEq)]
   pub enum DateOp {
       GreaterThan,
       GreaterEqual,
       LessThan,
       LessEqual,
   }

   #[derive(Debug, Clone, Copy, PartialEq)]
   pub enum FileType {
       File,
       Folder,
   }
   ```

   Add impl blocks for SizeOp::to_sql() and DateOp::to_sql() returning SQL operator strings.

4. Update src/lib.rs to export search module:
   ```rust
   pub mod search;
   ```
  </action>
  <verify>cargo check --lib</verify>
  <done>pest dependencies added, filter types defined, search module exported</done>
</task>

<task type="auto">
  <name>Task 2: Create pest grammar and parser</name>
  <files>src/search/grammar.pest, src/search/parser.rs</files>
  <action>
1. Create src/search/grammar.pest (exact grammar from RESEARCH.md):
   ```pest
   WHITESPACE = _{ " " | "\t" }

   query = { SOI ~ term* ~ EOI }
   term = { filter | word }

   filter = { filter_type ~ ":" ~ filter_value }
   filter_type = { "ext" | "size" | "type" | "modified" | "path" }
   filter_value = { quoted_string | comparison | word }

   comparison = { comparator ~ (size_value | date_value | word) }
   comparator = { ">=" | "<=" | ">" | "<" }
   size_value = { number ~ size_unit }
   size_unit = { ^"kb" | ^"mb" | ^"gb" | ^"tb" | ^"b" }
   date_value = { iso_date | relative_date }
   iso_date = @{ ASCII_DIGIT{4} ~ "-" ~ ASCII_DIGIT{2} ~ "-" ~ ASCII_DIGIT{2} }
   relative_date = { ^"today" | ^"yesterday" | ^"lastweek" | ^"lastmonth" | ^"lastyear" }

   word = @{ (wildcard | char)+ }
   wildcard = { "*" | "?" }
   char = { !(":" | " " | "\t" | "\"") ~ ANY }
   quoted_string = { "\"" ~ inner ~ "\"" }
   inner = @{ (!("\"") ~ ANY)* }
   number = @{ ASCII_DIGIT+ }
   ```

2. Create src/search/parser.rs:
   ```rust
   use pest::Parser;
   use pest_derive::Parser;
   use crate::{FFIError, Result};
   use super::filters::*;

   #[derive(Parser)]
   #[grammar = "src/search/grammar.pest"]
   struct SearchParser;

   #[derive(Debug, Clone, Default)]
   pub struct ParsedQuery {
       pub pattern: Option<String>,      // Name pattern with wildcards
       pub filters: Vec<Filter>,         // All parsed filters
   }

   pub fn parse_query(input: &str) -> Result<ParsedQuery> {
       // Parse with pest
       // For each term: if filter -> add to filters, if word -> append to pattern
       // Convert wildcards: * stays *, ? stays ? (SQL LIKE uses % and _)
       // Handle quoted strings as literal patterns
   }
   ```

   Implement parse_query to:
   - Parse input with SearchParser::parse(Rule::query, input)
   - Walk the parse tree
   - For filter terms: parse filter_type and filter_value into Filter enum
   - For word terms: collect into pattern (space-separated if multiple)
   - Size values: parse number and unit, convert to bytes (KB=1024, MB=1024^2, etc.)
   - Date values: parse relative dates using chrono (today, yesterday, lastweek, lastmonth, lastyear)
   - Return ParsedQuery with pattern and filters

3. Add parse_size_value helper to convert "10mb" -> 10485760 bytes

4. Add parse_date_value helper using chrono:
   - "today" -> start of today
   - "yesterday" -> start of yesterday
   - "lastweek" -> 7 days ago
   - "lastmonth" -> 30 days ago
   - "lastyear" -> 365 days ago
   - ISO date "2024-01-15" -> Unix timestamp
  </action>
  <verify>cargo check --lib</verify>
  <done>Grammar parses without errors, parse_query returns ParsedQuery</done>
</task>

<task type="auto">
  <name>Task 3: Implement SQL query builder with tests</name>
  <files>src/search/query.rs</files>
  <action>
Create src/search/query.rs with:

1. `pub fn build_sql_query(parsed: &ParsedQuery) -> (String, Vec<SqlParam>)`:
   - Build WHERE clause from pattern and filters
   - Pattern: Convert * to %, ? to _, wrap in LIKE with ESCAPE
   - Extension: `name LIKE '%.pdf'` (case-insensitive via COLLATE NOCASE)
   - Size: `size > ?` with bytes parameter
   - Type: `is_dir = 1` for folder, `is_dir = 0` for file
   - Modified: `modified > ?` with Unix timestamp
   - PathScope: Will need special handling (post-filter or recursive CTE) - for now, add comment noting this requires path reconstruction
   - Return base SELECT with WHERE clause and LIMIT placeholder

2. Define SqlParam enum:
   ```rust
   pub enum SqlParam {
       Text(String),
       Integer(i64),
   }
   ```

3. Add comprehensive tests:
   - test_simple_word: "document" -> LIKE '%document%'
   - test_wildcard: "*.pdf" -> LIKE '%.pdf'
   - test_question_wildcard: "doc?.txt" -> LIKE 'doc_.txt'
   - test_extension: "ext:pdf" -> LIKE '%.pdf'
   - test_size_greater: "size:>10mb" -> size > 10485760
   - test_size_less: "size:<1kb" -> size < 1024
   - test_type_folder: "type:folder" -> is_dir = 1
   - test_type_file: "type:file" -> is_dir = 0
   - test_modified_today: "modified:today" -> modified >= (today start)
   - test_combined: "report ext:pdf size:>1mb" -> multiple conditions ANDed
   - test_quoted_literal: `"my file.txt"` -> exact LIKE pattern
  </action>
  <verify>cargo test search --lib</verify>
  <done>All search parser tests pass, SQL queries generated correctly</done>
</task>

</tasks>

<verification>
1. `cargo check --lib` passes
2. `cargo test search --lib` passes (all parser tests)
3. Grammar file exists at src/search/grammar.pest
4. parse_query("test ext:pdf size:>10mb") returns ParsedQuery with pattern and 2 filters
5. build_sql_query produces valid SQL WHERE clause
</verification>

<success_criteria>
- pest grammar compiles and parses all search syntax variants
- Wildcards (* and ?) correctly identified in pattern
- All filter types parse: ext, size, type, modified, path
- Size units convert to bytes (KB, MB, GB, TB)
- Relative dates convert to Unix timestamps
- SQL query builder produces parameterized queries (no SQL injection)
- Comprehensive test coverage for parser and query builder
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-experience/03-03-SUMMARY.md`
</output>
