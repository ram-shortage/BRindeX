---
phase: 03-search-experience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/lib.rs
  - src/ipc/mod.rs
  - src/ipc/protocol.rs
  - src/ipc/server.rs
  - src/ipc/client.rs
autonomous: true

must_haves:
  truths:
    - "Service listens on named pipe for search requests"
    - "Client can connect and receive search results"
    - "Multiple clients can connect sequentially"
  artifacts:
    - path: "src/ipc/mod.rs"
      provides: "IPC module exports"
      exports: ["protocol", "server", "client"]
    - path: "src/ipc/protocol.rs"
      provides: "Message types for IPC"
      exports: ["SearchRequest", "SearchResponse", "FileResult", "PIPE_NAME"]
    - path: "src/ipc/server.rs"
      provides: "Named pipe server for service"
      exports: ["IpcServer"]
    - path: "src/ipc/client.rs"
      provides: "Named pipe client for UI"
      exports: ["IpcClient"]
  key_links:
    - from: "src/ipc/server.rs"
      to: "src/db/ops.rs"
      via: "search_files and reconstruct_path calls"
      pattern: "db::ops::(search_files|reconstruct_path)"
    - from: "src/ipc/protocol.rs"
      to: "serde_json"
      via: "JSON serialization"
      pattern: "serde_json::(from_slice|to_vec)"
---

<objective>
Create IPC layer using Windows named pipes for communication between the search UI and the FFI service.

Purpose: The search UI runs as a separate process and needs to query the service's database. Named pipes provide efficient, secure local IPC with built-in Windows integration.

Output: IPC module with protocol types, server (for service), and client (for UI).
</objective>

<execution_context>
@/Users/brett/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brett/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search-experience/03-RESEARCH.md

# Existing code context
@src/lib.rs
@src/db/ops.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add serde_json dependency and create IPC protocol types</name>
  <files>Cargo.toml, src/lib.rs, src/ipc/mod.rs, src/ipc/protocol.rs</files>
  <action>
1. Add serde_json to Cargo.toml:
   ```toml
   serde_json = "1.0"
   ```

2. Create src/ipc/mod.rs with module structure:
   ```rust
   pub mod protocol;
   pub mod server;
   pub mod client;

   pub use protocol::*;
   pub use server::IpcServer;
   pub use client::IpcClient;
   ```

3. Create src/ipc/protocol.rs with:
   - `PIPE_NAME: &str = r"\\.\pipe\FFI_Search"` constant
   - `SearchRequest` struct with: query (String), limit (usize), offset (usize)
   - `SearchResponse` struct with: results (Vec<FileResult>), total_count (usize), search_time_ms (u64)
   - `FileResult` struct with: id (i64), name (String), path (String), size (i64), modified (i64), is_dir (bool)
   - All structs derive Serialize, Deserialize, Debug, Clone
   - Add helper `read_message<T>` and `write_message<T>` async functions for length-prefixed JSON messages (4-byte little-endian length prefix + JSON bytes)

4. Update src/lib.rs to export ipc module:
   ```rust
   pub mod ipc;
   ```
   Also add FFIError::Ipc variant for IPC errors.
  </action>
  <verify>cargo check --lib</verify>
  <done>Protocol types compile, FFIError::Ipc variant exists, ipc module exported</done>
</task>

<task type="auto">
  <name>Task 2: Implement named pipe server for service</name>
  <files>src/ipc/server.rs</files>
  <action>
Create src/ipc/server.rs with IpcServer that:

1. Uses tokio::net::windows::named_pipe::{ServerOptions, NamedPipeServer}

2. `IpcServer::new(db: Arc<Mutex<Database>>)` constructor storing the database reference

3. `pub async fn run(&self, shutdown: tokio::sync::broadcast::Receiver<()>)`:
   - Loop: create new server instance, wait for connection, spawn handler
   - Use `tokio::select!` to check shutdown signal between connections
   - Pattern from RESEARCH.md: `ServerOptions::new().first_pipe_instance(false).create(PIPE_NAME)?`

4. `async fn handle_client(pipe: NamedPipeServer, db: Arc<Mutex<Database>>)`:
   - Read SearchRequest using protocol::read_message
   - Execute search: db.lock() -> search_files(query, limit)
   - For each result, call reconstruct_path to get full path
   - Build SearchResponse with FileResult items
   - Write response using protocol::write_message
   - Measure search_time_ms using std::time::Instant

5. Error handling: Log errors with tracing, don't crash on single client errors

6. Platform gate: Wrap entire module in `#[cfg(windows)]`
  </action>
  <verify>cargo check --lib (on Windows or with conditional compilation)</verify>
  <done>IpcServer compiles, has run() method accepting shutdown channel, handles SearchRequest</done>
</task>

<task type="auto">
  <name>Task 3: Implement named pipe client for UI</name>
  <files>src/ipc/client.rs</files>
  <action>
Create src/ipc/client.rs with IpcClient that:

1. Uses tokio::net::windows::named_pipe::ClientOptions

2. `IpcClient::new()` constructor (stateless - connects per request)

3. `pub async fn search(&self, query: &str, limit: usize) -> Result<SearchResponse>`:
   - Connect to named pipe: `ClientOptions::new().open(PIPE_NAME)?`
   - Build SearchRequest with query, limit, offset: 0
   - Write request using protocol::write_message
   - Read response using protocol::read_message
   - Return SearchResponse

4. `pub async fn search_with_offset(&self, query: &str, limit: usize, offset: usize) -> Result<SearchResponse>`:
   - Same as above but with custom offset for pagination

5. Error handling: Convert pipe errors to FFIError::Ipc

6. Platform gate: Wrap entire module in `#[cfg(windows)]`

7. Add unit test (integration-style) in tests block:
   - Test that IpcClient can be constructed
   - Note: Full integration test requires running server (will verify in manual testing)
  </action>
  <verify>cargo check --lib</verify>
  <done>IpcClient compiles, search() and search_with_offset() methods exist</done>
</task>

</tasks>

<verification>
1. `cargo check --lib` passes
2. IPC module exports: protocol, server, client
3. Protocol defines PIPE_NAME, SearchRequest, SearchResponse, FileResult
4. Server has run() accepting shutdown channel
5. Client has search() and search_with_offset() methods
6. All code has #[cfg(windows)] gates for cross-platform development
</verification>

<success_criteria>
- IPC module compiles without errors
- Protocol types are serializable/deserializable with serde_json
- Server uses loop pattern from RESEARCH.md for multiple client connections
- Client provides simple async API for search queries
- Length-prefixed messages prevent partial read issues
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-experience/03-01-SUMMARY.md`
</output>
